#+TITLE: Reading-For-Programmers
#+URL: https://codearsonist.com/reading-for-programmers
#+AUTHOR: lujun9972
#+TAGS: raw
#+DATE: [2017-06-29 四 10:57]
#+LANGUAGE:  zh-CN
#+OPTIONS:  H:6 num:nil toc:t \n:nil ::t |:t ^:nil -:nil f:t *:t <:nil


内容提要: 使用三步阅读法(verify(查证)-grasp(领会)-analyse(分解))轻松阅读 [[https://twitter.com/peel/status/840604048629874688][数百篇论文]]. 使用 org-mode (w/ helm-bibtex, org-ref and interleave) 来记笔记.

* Introduction

随着计算资源迅速变得廉价以及分布式编程的兴起,软件商务与学术贴合的越来越紧密.
现在软件得以,而且确实严重依赖于学术的进步. 
前沿研究应用于日常代码也开始变得很常见. 我们当然可以忽略代码背后的那些概念,但是也可以拥抱变化,努力适应这一变化. 
你可以使用现成的库和开源方案并忽略其内部原理,也可以尝试去理解这些方案的理念,查看其内部实现.
要跟上科学进步的步伐需要有强大的意志力,甚至有时为了阅读一片科技论文需要进行10个阅读步骤.
(Following the scientific advancements requires a significant willpower and either way it merely leads toward 10 Stages of Reading a Scientific Paper[[https://codearsonist.com/reading-for-programmers#fn.1][1]].)
不过你大可不必如此,只需要使用某个方法就可以跳过那些令人痛苦的步骤...

[[https://codearsonist.com/img/rfp-abstract.png]]

* Three-pass reading

不止一次地,有人提出[[https://codearsonist.com/reading-for-programmers#fn.2][2]], [[https://codearsonist.com/reading-for-programmers#fn.3][3]] 阅读论文 (事实上是阅读任何需要充分理解高级概念的东西) 需要分多步来进行. 
其主要思想是,在每次阅读论文时,你的头脑中都需要有一个明确的目标.
第一步,你需要查证这篇文章及其内容; 第二步,你需要领会文章的大意; 第三步,你完全理解这些概念 and get your notes flowing. 

** First pass - Verify

第一步需要你从高层视角来审视论文的内容(The first pass provides you with a high-level view of the contents.)
它使你不会因为糟糕的写作,不感兴趣的内容,错误的或者不足的知识背景而卡住.
为了充分利用这第一步,我常常从引用文献开始. 虽说根据统计, 80%的作者都不会通读其所引用的文字 [[https://codearsonist.com/reading-for-programmers#fn.4][4]], 但是这些文献在很大程度上能告诉你能从这篇文章中收获到哪些东西.
我在开始阅读一篇又长又复杂的论文之间,我都会先标记一下哪些被引用的文章是我之前已经阅读过的,这样方便我查回之前所记录的笔记并且查证论文的背景知识.
当第一次阅读论文时,我会仔细阅读它的标题.摘要和引言. 他们决定了这篇文章是否值得阅读.
然后,我再扫读一遍这篇文章,主要关注它的章节标题,图形和数学公式. 
我还会阅读论文的结论和讨论部分(I also read the results and discussion section to have an overview of where I will be lead with the article). 
最近风靡HackerNews的论文 "How to read papers" [[https://codearsonist.com/reading-for-programmers#fn.2][2]]  的作者建议你在第一次阅读时应该回答5个以C开头的问题:

+ Category - 这是那种类型的论文? 
+ Context - 它还与那些论文相关? 论文中使用了那些理论基础来分析问题? 
+ Correctness - 论文所基于的假设条件是否真实? 
+ Contributions - 这篇文章的主要贡献有哪些? 
+ Clarity - 这篇文章写够不够好? 

就我自己来说,第一次阅读除了让我了解论文的基本脉络之外,还决定了是否要进行第二次的阅读. 我会问我自己:

+ 我能从中学到什么? 
+ 我是否有足够的背景知识来理解这篇文章? 

阅读论文诚然可以极大地丰富你的知识,提供实践方案,学到做事的方法论,甚至提供实验设计的概念(experimental design concepts). 但它也要求你有相应的先验知识(背景知识). 
当我在第一次阅读时发现有缺失的背景知识时,我会将这篇文章标记为 =TODO=, 并增加一个 =:advanced:= 标签,然后把它放在一边直到我通过阅读它的引用文献或通过Internet补足了背景知识后才再次阅读.

** Second pass - Grasp concepts

第二次阅读的目的在于理解概念及其支持证据. 我一般将论文放在的 Onyx Boox 大屏电子纸阅读器中而不会打印出来.
这使得我可以很方便地跟上思维的处理过程(follow thought process), 将注意力放在概念上而不是具体的细节上.
在阅读的过程中,我会标记,高亮重点并在纸张的边上写下笔记. 之后,我只要快速扫一下就能知道这篇文章的重点了.
我会尝试通过表格和图形展示来加深理解. 
当遇到我不能理解的东西时, 要看它是否会影响到后面概念的理解,还是说我可以把它记录下来下次再来学习它. 
若会影响到后面概念的理解,则在进行后续的阅读前必须先把它搞定. 所以… 在google上搜索它, 或者翻阅之前的笔记, 总之要把它学会. 
第二次阅读时我还会关注 =内联引用(inline references)=. 有些引用是 instant hook, 我会把他们添加到待阅读的论文列表中. 
这样在第二次阅读之后,我就有了一个满是笔记的,标注过的,高亮过的论文了. 而且我还理解了它的概念并且能将这些理念分享给他人.
不过对于那些很重要的概念来说,这还不够,还需要再阅读第三遍.

** Third pass - Critique

只有对那些真正感兴趣的论文才需要进行第三次阅读. 
I work my way through the parts I missed previously and try to see the results/discussion in a larger
spectrum. Ie. How does profunctor optics relate to extensive domains we've built? The third
pass is also where I tend to differ from some of the academics. It is said, that in order to
review a paper you need to recreate it without copying. I usually do that only with the
papers that are vital to my work. I pick the tools I use and try to rebuild that. Indeed it can
make one angry. It will get on your nerves and you will hate the ideas. But in the end the
grand idea is usually worth it. The third pass usually ends up with a bit of code and notes.
Or just the notes. But the notes are where it all belongs. Third pass is for the active reader.
Even if the article is not core to the things I do and I decide not to fiddle around in REPL I am
an active reader. I mark even more things, note stuff (that usually won't fit in margins) on
the side. I don't copy stuff. Use my own words so I process it. I use structured notes -
outline. I critically look for inconsistencies. Is the reasoning right? Is the samples number
sufficient? 

* The Notes

I have been tinkering with the notes workflow for a couple of years. With lots of notes and
papers read it gets tedious to grep files for related notes. And it is somewhere on the verge
of madness to have it all stored in a paper notebook. As an avid Emacs uses I have been
taking notes with the almighty [[http://orgmode.org][org-mode]]. An extensible Emacs major mode for all things
text/data related. With org-mode's minimal syntax and tree layout it is incredibly easy to
structure and extend the simple, single-file knowledge base. 

** The workflow

I have been keeping a huge notes papers.org and a references papers.bib files for a couple
of years now. The files contain an abysmal list of books, papers and articles I've been tagging
as TODO. Usually to avoid fiddling around I just add a quick TODO of a document with an
org-capture[[https://codearsonist.com/reading-for-programmers#fn.5][5]] template (be it paper, article, link, whatever). Every now and then (usually
whenever picking the next paper to read) I go through the file and turn the captures into
proper Bibtex references. 

[[https://codearsonist.com/img/rfp-bibtex.png]]

Figure 2: Bibtex has been a de-facto standard reference management system for years now

Bibtex has been a de-facto standard reference management system for years now. Hence it
is perfectly possible to grab all the necessary document details from the Internet. Either by
searching by name, title, tag or… a pdf file. I usually either drag and drop a downloaded pdf
onto Emacs window with references files so it fetches the data on it's own. Or… just use the
beautiful [[https://github.com/tmalsburg/helm-bibtex][helm-bibtex]] which allows me to quickly access all the major scientific search
engines from arxiv to google scholar. 

[[https://codearsonist.com/img/rfp-helm-bibtex.png]]

Figure 3: helm-bibtex allows quick access to references

I also turn the capture TODO into a document TODO task in the papers.org itself. However to
keep thing optimised, it gets done using the reference - enter [[https://github.com/jkitchin/org-ref][org-ref]]. A quick shortcut and
the reference and TODO are now linked. My usual workflow for taking notes starts with the
third pass which I usually do in Emacs' [[https://github.com/politza/pdf-tools][pdf-tools]] anyway. Running a REPL or a worksheet
side-by-side with a paper is invaluable. Same goes for taking notes. And guess what,
everything I have done so far enables me to use a single command to link notes to specific
places in a pdf. Enabling interleave mode (M-x interleave, duh) on given subtree (with
:INTERLEAVE_PDF: property set) allows that by simply attaching pdf location. And voila: 

[[https://codearsonist.com/img/rfp-interleave.png]]

Figure 4: iterleave allows linking notes to pdf parts

With that at hand I'm able to effectively keep the notes neatly connected to source material.
And between each other using org-mode subtree search and tags. 

** The setup

The setup is indeed prety straight-forward to achieve. A couple of packages and a minimal
configuration options. I store my dotfiles in a github repository. My (now migrated from plain
ol' init.el) spacemacs config's there as well. Feel free to [[https://dotfiles.codearsonist.com][roam around and steal stuff -]]
[[https://dotfiles.codearsonist.com][dotfiles.codearsonist.com]]. 

*** pdf-tools

A prereq for Emacs to be able to display pdfs properly. I'm using stock configuration without
extra options. 

*** org-ref

org-ref also requires just a minimal setup to get the wheels turning and the configuration
corresponds the helm-bibtex one: 

#+BEGIN_SRC emacs-lisp
  (setq org-ref-notes-directory "$SOME"
        org-ref-bibliography-notes "$SOME/index.org"
        org-ref-default-bibliography '("$SOME/index.bib")
        org-ref-pdf-directory "$SOME/lib/")
#+END_SRC

*** helm-bibtex

I guess org-ref config should be propagated down to the helm-bibtex one. But here's how
you'd configure helm-bibtex directly: 

#+BEGIN_SRC emacs-lisp
  (setq helm-bibtex-bibliography "$SOME/index.bib" ;; where your references are stored
        helm-bibtex-library-path "$SOME/lib/" ;; where your pdfs etc are stored
        helm-bibtex-notes-path "$SOME/index.org" ;; where your notes are stored
        bibtex-completion-bibliography "$SOME/index.bib" ;; writing completion
        bibtex-completion-notes-path "$SOME/index.org"
        )
#+END_SRC

*** interleave

None. Set the :INTERLEAVE_PDF: property on subtree in papers.org and you're done 🎉️ 

* Picking the next paper

As a side note. The Internet is full of papers. Hackernews, Twitter stream, Reddit produce
must read items quicker than we will ever be able to follow. From my personal experience
though the best source of papers are simply references from other papers. Each specialty
has its own paper 'canon'. Start with them and gradually work your way towards others
either by following citations (CiteSeer, Google Scholar) or references directly. Keep in mind
that citations number is a pretty good sanity check whenever a paper is getting
recommended. 

* Summary

Armed with a method of reading scientific material I have read numerous deeply technical
papers. Often beyond my usual knowledge level. The approach allows me for improving my
reading skills (also see: [[https://codearsonist.com/reading-for-programmers#fn.6][6]]) with each paper I read. The more I read the better my
understanding is. I am able to share the knowledge by discussing it with other people. All
the above is the basic workflow idea I have been working with and find it perfect for my
needs. There is more to it including automated tag dependency graphing I have
implemented. But that is a separate (long) story… 

Footnotes: 

[[https://codearsonist.com/reading-for-programmers#fnr.1][1]] Ruben, A. (2016). How to read a scientific paper. [[http://www.sciencemag.org/careers/2016/01/how-read-scientific-paper][Accessed at 07/06/17]] 

[[https://codearsonist.com/reading-for-programmers#fnr.2][2]] Pain, E. (2016). How to (seriously) read a scientific paper. [[http://www.sciencemag.org/careers/2016/03/how-seriously-read-scientific-paper][Accessed at 07/06/17]] 

[[https://codearsonist.com/reading-for-programmers#fnr.3][3]] Keshav, S. (2013). How to Read a Paper. [[http://www.albany.edu/spatial/WebsiteFiles/ResearchAdvices/how-to-read-a-paper.pdf][Accessed at 07/06/17]] 

[[https://codearsonist.com/reading-for-programmers#fnr.4][4]] Simkin, M.V. and Roychowdhury V.P. (2002). Read before you cite! [[https://arxiv.org/pdf/cond-mat/0212043.pdf][Accessed at 07/06/17]] 

[[https://codearsonist.com/reading-for-programmers#fnr.5][5]] A quick-access scrapnote-taking utility

[[https://codearsonist.com/reading-for-programmers#fnr.6][6]] Bayard, P. (2009). How to Talk About Books You Haven't Read. Bloomsbury USA 
