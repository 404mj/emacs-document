#+URL: http://kitchingroup.cheme.cmu.edu/blog/2017/03/22/A-better-defun-for-emacs-lisp/
#+AUTHOR: lujun9972
#+DATE: [2017-04-09 Sun 14:41]
#+TAGS: processing
#+LANGUAGE: zh-CN
#+OPTIONS: H:6 num:nil toc:t \n:nil ::t |:t ^:nil -:nil f:t *:t <:nil

我一直在想以怎样的方式来写代码才能拥有漂亮的文档. 这些文档应该是随代码实时更新的,最好还能够做到自动校验.
有一种实现的方法就是将文档与代码紧密地结合起来. 越紧密越好. 
我在 [[http://kitchingroup.cheme.cmu.edu/blog/2017/03/19/A-Hy-macro-for-defining-functions-with-docstrings-on-each-argument/][上一篇文章中]] 进行过一些有趣的尝试, 我通过宏来让我在定义函数参数的同时也指定参数的docstring. 
这一次我扩展了这个思想,除了生成文档说明之外,还能提供参数的默认值以及要插入函数中的参数验证代码.
本文以Emacs-lisp为例,但仅仅是因为我对它比较熟悉而已. 这个思想应该对其他lisp系语言都是通用的.

考虑下面这个原型, 很普通的函数定义,用法和docstring. 

#+BEGIN_SRC emacs-lisp
  (defun f1 (arg1 arg2)
    "Add two numbers."
    (+ arg1 arg2))

  ;; usage
  (f1 3 4)
#+END_SRC

可以在Emacs中查看它的帮助信息. 

#+BEGIN_SRC emacs-lisp
  (describe-function 'f1)
#+END_SRC

很明显,我懒得写docstring; 这条docstring中甚至没有关于参数的只言片语. 而且函数中也没有对参数进行校验,你可以传入一个字符串和一个数字,但是结果会报错.
也没有给参数提供默认值,这样你就必须同时提供两个参数的值才能调用该函数. 很明显这个函数还有很大的改进空间.  
当然如果我不嫌麻烦,我也可以写出一个更好的函数,像这样: 

#+BEGIN_SRC emacs-lisp
  (defun f1a (arg1 &optional arg2)
    "Add ARG1 and ARG2 together.
  ARG1 and  ARG2 should both be numbers."
    (when (null arg2) (setq arg2 2))
    (unless (and (numberp arg1) (numberp arg2)) (error "arg1 and arg2 should both be numbers"))
    (+ arg1 arg2))

  (list (f1a 3 4) (f1a 3))
#+END_SRC

Yes, I could do that, but it is tedious to do it all the time. And it still leaves something to be desired for me. The
docstring does not say what the default value is for example, and that is hard-coded in the code, i.e. not introspectible
until you look at the code. Next we consider an alternative way to write the function. Compare that to this function
definition, usage and documentation. The function definition is a little more verbose. Providing documentation, defaults and
validation code in any form would make it that way no matter what. 

#+BEGIN_SRC emacs-lisp
  (defn f2 ((arg1 "A number" :validate numberp)
            (arg2 "A number" :validate numberp :default 2))
    "Add the arguments."
    (+ arg1 arg2))

  ;; usage
  (list (f2 3 4) (f2 3))
  (describe-function 'f2)
#+END_SRC

The documentation is built up from the information in the function definition, in a form that is mostly consistent with
emacs-lisp documentation standards. defn is not a regular emacs-lisp function; it is a macro I developed to generate the
function code. It turned out to be long, but the gist of it is that before defining the function I loop through the
arguments and collect the docstrings, along with any information about default values and/or validation functions. Then I
build up the list of arguments to put in the function. Then if any default values are set, I generate some code to set those
values if they are not set in the function call, and finally a similar block of validation code. At the end, I construct the
defun and return it. You can check out the code if you want here:
[[https://github.com/jkitchin/scimax/blob/master/scimax-macros.el][https://github.com/jkitchin/scimax/blob/master/scimax-macros.el]]. 

Let's take a look at what this code expands to. 

#+BEGIN_SRC emacs-lisp
  (macroexpand-1
   '(defn f2 ((arg1 "A number" :validate numberp)
              (arg2 "A number" :validate numberp :default 2))
      "Add the arguments."
      (+ arg1 arg2)))
#+END_SRC

You can see it expands to a regular defun, with a generated docstring, generated default settings code block, and generated
validation code. Pretty nice. 

Let's see what happens with a function that fails the validation. We should get an error. Here we capture the error so we
can see it in the post. 

#+BEGIN_SRC emacs-lisp
  (condition-case err
      (f2 "oak")
    (error
     (error-message-string err)))
#+END_SRC

So we even get a useful error message when the wrong type of argument is provided. Compare that to the error message from
the original version of this function. It tells us we got the wrong type, but not which argument. 

#+BEGIN_SRC emacs-lisp
  (condition-case err
      (f1 "oak" 4)
    (error
     (error-message-string err)))
#+END_SRC

One last example to check out the &rest argument, with validation that every arg is a number. 

#+BEGIN_SRC emacs-lisp
  (defn f4 ((rarg :rest
                  :validate (lambda (x)
                              (-all-p 'identity (mapcar 'numberp x)))))
    "multiply all the arguments."
    (apply '* rarg))

  (f4 1 2 3)
  (condition-case err
      (f4 "oak" 4)
    (error
     (error-message-string err)))
  (describe-function 'f4)
#+END_SRC

That looks ok too. 

* Summary

The motivation for this was to help me write better code with better documentation. Better code in the sense that it can
provide run-time validation, with better feedback, and automatic documentation, including that there is none if that is the
case. It is basically compatible with the regular defun, but enhances what kind of documentation is possible with less work
on my part. I think it will make it easier to keep documentation in sync, since the argument documentation would be kept
near the argument, and you can build in validation if you want to. 

It is no news to lispers that macros are good for this kind of application. 
