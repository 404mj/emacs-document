#+URL: https://www.masteringemacs.org/article/pcomplete-context-sensitive-completion-emacs
#+AUTHOR: lujun9972
#+DATE: [2017-04-13 四 18:20]
#+TAGS: processing
#+LANGUAGE: zh-CN
#+OPTIONS: H:6 num:nil toc:t \n:nil ::t |:t ^:nil -:nil f:t *:t <:nil

我在 /What’s New In Emacs 24/系列文章中([[/articles/2011/12/06/what-is-new-in-emacs-24-part-1/][part one]], [[/articles/2011/12/12/what-is-new-in-emacs-24-part-2/][part two]]) 简单地提到过pcomplete([[/articles/2010/12/13/complete-guide-mastering-eshell/][Eshell]]中使用的可编程补全库)现在也能直接在 =M-x shell= 中使用了.
这对喜欢shell mode的人来说可真是个好消息, 因为原来的shell mode并没补全功能(而补全的能力是底层shell本身就提供的).

令人吃惊的是,补全机制在Emacs已经存在很久了,但是它在Emacs中很少用到,这使得大多数人对它知之甚少.
事实上,我估计只有Eshell,ERC,Org Mode和现在Shell Mode中采用到了这个包吧.

* Programmable, Context-Sensitive Completion

从Emacs 24开始,你什么都不用做就能使用 =pcomplete=, 当你打开一个新的shell session时,Emacs会自动做好相应的准备. 
Emacs自带了很多 =pcomplete= 函数能够加强Emacs之前那种单纯的文件名补全的能力,使之能提供类似bash/zsh的那种基于上下文的补全. 
尤其为 =scp=, =ssh=, =mount=, =umount= 和 =make= 命令提供了很好的补全支持.

下面列出的是那些shell mode支持补全的命令(事实上该列表适用于任何支持pcomplete的mode,包括Eshell.)

  + bzip2

    补全参数,并且只列出经过bzip2压缩后的文件.

  + cd

    补全目录.

  + chgrp

    补全系统中已有的祖名.

  + chown

    补全用户和组,但只有使用 =user.group= 时才有用.

  + cvs

    补全命令和参数选项,还有cvs entry 以及 module.

  + gdb

    补全目录以及具有执行权限的文件

  + gzip

    补全参数并只列出经过gzip压缩过后的文件.

  + kill

    在 - 后面会列出signal,否则的话会补全所有的进程号.

  + make

    补全参数以及目录中的所有makefile; 在 =make -f FILE= 后则会补全文件中的rule名称.

  + mount

    补全参数,以及 =mount -t TYPE= 中的文件系统类型.

  + pushd

    与cd的补全方式一样

  + rm

    补全参数,文件名以及目录.

  + rmdir

    补全目录.

  + rpm

    rpm的补全机制实现的非常精妙. 能够根据上下文环境补全几乎所有的子命令,包括补全package名称.

  + scp

    能够补全命令参数, SSH认证过的主机,并且在命令格式为 =scp host:/= 时还能补全远程服务器上的文件路径(借助TRAMP来实现).

  + ssh

    补全命令参数,以及SSH认证过的主机.

  + tar

    补全命令参数,尤其能根据上下文智能补全符合POSIX标准的参数,还能补全文件名.

  + time

    补全目录,以及带有执行权限的命令.

  + umount

    补全命令参数,挂载的目录以及文件系统类型(与mount类似)

  + which

    本应能提供对所有二进制文件的补全,但貌似不能正常工作.

  + xargs

    补全目录以及带有可执行权限的文件.

* Custom Completion

It goes without saying that a completion library called /programmable completion/ is, well, programmable.

Adding simple parameter completion is an easy job but anything more than that and it gets hairy as, not surprisingly, this library is virtually undocumented
(though an optimist would say the source is all the documentation you need…)

I’ll demonstrate how to add rudimentary support for git.

The first thing we need to do is establish the order in which parameters must be given; for git, it’s somewhat consistent: git [options] <command> [<args>]

For now I’ll stick to the commands as that’s what people use the most anyway. The commands, in list form, are:

#+BEGIN_SRC emacs-lisp
  (defconst pcmpl-git-commands
    '("add" "bisect" "branch" "checkout" "clone"
      "commit" "diff" "fetch" "grep"
      "init" "log" "merge" "mv" "pull" "push" "rebase"
      "reset" "rm" "show" "status" "tag" )
    "List of `git' commands")
#+END_SRC

The syntax for pcomplete is rather clever: it will use dynamic dispatch to resolve the elisp function provided it is named a certain way. All commands are named
pcomplete/COMMAND or pcomplete/MAJOR-MODE/COMMAND. Provided you follow that naming scheme your command will automagically work.

Next, we need to present a list of valid commands – in this case the ones in pcmpl-git-commands, but it could be any form – to the command pcomplete-here.

#+BEGIN_SRC emacs-lisp
  (defun pcomplete/git ()
    "Completion for `git'"
    (pcomplete-here* pcmpl-git-commands))
#+END_SRC

Now when you try to tab-complete the first argument to git it will list our commands. Sweet.

Let’s extend it further by adding support for the add and rm commands. I want the aforementioned commands to provide the standard filename/filepath
completion if, and only if, the command is add or rm.

This is surprisingly easy to do using pcomplete-match, a function that asserts a certain regexp matches a particular function argument index. Note that the call to
pcomplete-here is in a while loop; this is so you can complete as many files as you like, one after another. One advantage of pcomplete-here is that it won’t display
files you have already completed earlier in the argument trail – that’s very useful for a command like add.

#+BEGIN_SRC emacs-lisp
  (defun pcomplete/git ()
    "Completion for `git'"
    ;; Completion for the command argument.
    (pcomplete-here* pcmpl-git-commands)

    ;; complete files/dirs forever if the command is `add' or `rm'.
    (if (pcomplete-match (regexp-opt '("add" "rm")) 1)
        (while (pcomplete-here (pcomplete-entries)))))
#+END_SRC

Ok, that was easy. Now let’s make it a bit more dynamic by extending our code to support the git checkout command so it will complete the list of branches
available to us locally.

To do this we need a helper function that takes the output of a call to shell-command and maps it to an internal elisp list. This is easily done with some quick
hackery.

The variable pcmpl-git-ref-list-cmd holds the shell command we want Emacs to run for us. It gets every ref there is and we then filter by sub-type (heads, tags,
etc.) later. The function pcmpl-git-get-refs takes one argument, type, which is the ref type to filter by.

#+BEGIN_SRC emacs-lisp
  (defvar pcmpl-git-ref-list-cmd "git for-each-ref refs/ --format='%(refname)'"
    "The `git' command to run to get a list of refs")

  (defun pcmpl-git-get-refs (type)
    "Return a list of `git' refs filtered by TYPE"
    (with-temp-buffer
      (insert (shell-command-to-string pcmpl-git-ref-list-cmd))
      (goto-char (point-min))
      (let ((ref-list))
        (while (re-search-forward (concat "^refs/" type "/\\(.+\\)$") nil t)
          (add-to-list 'ref-list (match-string 1)))
        ref-list)))
#+END_SRC

And finally, we put it all together. To keep the code clean I’ve switched to using a cond form for readability.

#+BEGIN_SRC emacs-lisp
  (defconst pcmpl-git-commands
    '("add" "bisect" "branch" "checkout" "clone"
      "commit" "diff" "fetch" "grep"
      "init" "log" "merge" "mv" "pull" "push" "rebase"
      "reset" "rm" "show" "status" "tag" )
    "List of `git' commands")

  (defvar pcmpl-git-ref-list-cmd "git for-each-ref refs/ --format='%(refname)'"
    "The `git' command to run to get a list of refs")

  (defun pcmpl-git-get-refs (type)
    "Return a list of `git' refs filtered by TYPE"
    (with-temp-buffer
      (insert (shell-command-to-string pcmpl-git-ref-list-cmd))
      (goto-char (point-min))
      (let ((ref-list))
        (while (re-search-forward (concat "^refs/" type "/\\(.+\\)$") nil t)
          (add-to-list 'ref-list (match-string 1)))
        ref-list)))

  (defun pcomplete/git ()
    "Completion for `git'"
    ;; Completion for the command argument.
    (pcomplete-here* pcmpl-git-commands)  
    ;; complete files/dirs forever if the command is `add' or `rm'
    (cond
     ((pcomplete-match (regexp-opt '("add" "rm")) 1)
      (while (pcomplete-here (pcomplete-entries))))
     ;; provide branch completion for the command `checkout'.
     ((pcomplete-match "checkout" 1)
      (pcomplete-here* (pcmpl-git-get-refs "heads")))))
#+END_SRC

And that’s that. A simple completion mechanism for git. Put this in your .emacs or init file and you’re done.
